# List defined functions 
function funclist() {
    declare -f | grep "()" | egrep -v "^[_ \$]"
}
# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}
# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh
    else
        local arg=-sh
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@"
    else
        du $arg .[^.]* *
    fi
}
# Create a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1")
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}
# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
    if [ -t 0 ]; then # argument
        python -mjson.tool <<< "$*" | pygmentize -l javascript
    else # pipe
        python -mjson.tool | pygmentize -l javascript
    fi
}
# Escape UTF-8 characters into their 3-byte format
function escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo # newline
    fi
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo # newline
    fi
}

# Get a character’s Unicode code point
function codepoint() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo # newline
    fi
}

# Find an application CFBundleIndentifier
function appid() {
    grep 'CFBundleIdentifier' -A1 "$1Contents/Info.plist" | sed s/string//g | sed s/key//g | sed s/[\<\>\/]//g
}
# NPM
function activate_npm {
    export PATH=/usr/local/share/npm/bin:${PATH}
}
function deactivate_npm {
    IFS=':' read -a path_segments <<< "${PATH}"
    NEW_PATH=""
    for ps in "${path_segments[@]}"; do
        if [ "/usr/local/share/npm/bin" != "$ps" ]; then
            if [ -z "$NEW_PATH" ]; then
                NEW_PATH=$ps
            else
                NEW_PATH=$NEW_PATH:$ps
            fi
        fi
    done
    echo $NEW_PATH
}
